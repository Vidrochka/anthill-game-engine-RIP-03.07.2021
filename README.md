# anthill-game-engine

Now, its jast a some kind of trash with plan. Look at the future...

# Goals

---

- #### Shared types

:white_check_mark: Тип строки для u8/u16/u32 (u8string_at/u16string_at/u32string_at)     
:white_check_mark: Методы конвертирования меджу кодировками     
:white_check_mark: Каст int типов в u8/u16/u32 строки (надо доработать под шаблонный тип для универсальности)     
:white_check_mark: Добавлен хвост u8at для преобразования строковыхлитералов в u8string_at
```cpp
auto text = "text"u8at
//text имеет тип u8string_at
```
:white_check_mark: U8StringBuilder - тип-форматер строк. Пожалуй одна из самых моих любимых частей в проекте     
* fmt(u8string_at regex, T formatter) -> U8StringBuilder& - шаблонный метод, по регулярке заменяет значения в строке на параметр вызывая to_string()    
* fmt(int param_number, T formatter) -> U8StringBuilder& - шаблонный метод, по номеру замамены заменыет {N} на переданное значение     
* перегружен для неявного преобразования в u8string_at   

:white_check_mark: RGB_at и RGBA_at - шаблонные классы для представления цвета    
* метод to_vector возвращает std::vector из компонент цвета (from_vector противоположное действие)    
* метод to_string формирует строку читаемого вида для логгирования     
* метод get_black и get_white возвращают крайние значения определенные для шаблонного типа     

---

- #### Guid

:white_check_mark: Реализована система guid. Тип id можно специализировать числовым шаблонным типом    
* release_id(id_type id) - уменьшают счетчик максимального id если это крайнее значение или сохраняются в вектор для последующей выдачи    
* get_new_id() - возвращает новый id если в коллекци высвобожденных id пусто, иначе достает сохраненный id
* defragmentate() - сортирует коллекцию и уменьшает счетчик id если есть крайние id

---

- ### Logging
:white_check_mark: Добавить интерфейс менеджера логов    
:white_check_mark: Реализовать интерфейс менеджера логов    
:white_check_mark: Добавить общий интерфейс стратерии логирования    
:white_check_mark: Реализовать интерфейс стратерии логирования в файл с простым буфферизированием     
:white_check_mark: Добавить общий интерфейс логгера    
можно спавнить множество логгеров для одного контекста с стратегиями, т.е. писать из разных частей системы в один лог     
:white_check_mark: Сделать простую реализоцию лога   
:white_check_mark: Добавить поддержку юникода    
По факту используется обычный string, если я не правильно сделал, прошу мне сообщить. Если еще и скажете как сделать правильно, то вообще респект будет    
:black_square_button: Подумать об асинковой записи в лог. Пока не до этого, вернусь позже *помощь тут приветствуется* [freez]    

---

<details>
  <summary>Config manager</summary>

Эта секция была скрыта т.к. автор осознал что легче и правильнее взять готовое решение нежели городить велосипеды    
Пока добавлена зависимость https://github.com/nlohmann/json
В ближайшее время добавлю еще https://github.com/ToruNiina/toml11 и что-то для xml

- ### Config manager

:white_check_mark: Добавить интерфейсы конфига и серций конфига    
:white_check_mark: Сделать базовы имплементации интерфейсов конфига и секции    
:white_check_mark: Добавить интерфейс источника данных     
:white_check_mark: Сделать реализацию источника из файла    
:black_square_button: Сделать реализацию источника из стрима *пока не надо, по этому отложил* [freez]    
:black_square_button: Сделать реализацию источника из базы (sqlite) *пока не надо, по этому отложил* [freez]    
:white_check_mark: Добавить интерфейс стратегии парсинга     
:white_check_mark: Сделать реализацию парсинга toml     
Он мне больше всего нравится, по этому реализован в первую очередь, но не спорю что кривовато    
Странные трансформации с u8 в u32 и обратно сделаны для возможности использовать regex для работы с char32_t как с отдельным unicode символом,     
но при этом мы храним как utf8 для экономии памяти. Мб костыльно, но работает и не надо тянуть зависимости библиотек работы с unicode    
:black_square_button: Сделать реализацию парсинга json/xml/yaml *пока не надо, по этому отложил* [freez]    
:white_check_mark: Добавить статические функции менеджеа конфигов     
По сути сделано для удобочитаемости кода объединения стратегии и источника, то же самое можно сделать в коде     
  
</details>

---

- ### Window manager

:black_square_button: Удалить интерфейс WindowManager-а, т.к. работа будет только с SDL реализвцией (безсмысленно что либо еще брать)
:black_square_button: Реализовать класс работы с оконной системой SDL2    
* :white_check_mark: open_preload_window(PreloadWindowInitializeSettings settings) - открывает окно предзагрузки с изображением (пока не закрыт нельзя открыть основное окно)     
* :black_square_button: close_preload_window()     
* :black_square_button: open_new_window(const WindowInitializeSettings settings) - отрывает новое окно по настройкам. Скорее всго претерипит определенные изменения для многооконной системы    

:white_check_mark: DTO с настройками для открытия preload окна - "PreloadWindowInitializeSettings"
:white_check_mark: DTO с настройками для открытия основного окна - "WindowInitializeSettings"
:black_square_button: Добавить пожддержку многооконной системы     

---

- ### Render system

Пока реализую отрисовку opengl как самую удобную для быстрого poc. В последствии обязательно добавлю vulkan как основной вид рендера

:white_check_mark: Составить интерфейс рендера методы рендера:    
* draw_rectangle() - Отрисовка прямоугольника (параметры по ходу пойму какие надо)     
* draw_triangle() - Отрисовка треугольника (параметры по ходу пойму какие надо)       
* draw_circle() - Отрисовка круга (параметры по ходу пойму какие надо)      
* draw_text() - Отрисовка текста (параметры по ходу пойму какие надо)     
* draw_line() - Отрисовка линии (параметры по ходу пойму какие надо)     
* draw_frame() - Отрисовка обрамляющей линии (параметры по ходу пойму какие надо)     
* draw_image(std::shared_ptr<type::image::Image> image, uint_fast32_t shader_program_id, Rect<int_fast32_t> rect) - Отрисовка изображения (реализованно для opengl)
* add_shader(std::ifstream& shader_stream, SHADER_TYPE shader_type) -> uint_fast32_t - добавляет шейдер в коллекцию + возвращает id шейдера    
В реализации opengl id шейдера непосредственно id шейдера, в vulkan будет map с id    
* add_shader(u8string_at shader_file_name, SHADER_TYPE shader_type) -> uint_fast32_t - см. выше    
* add_shader(std::stringstream& shader_stream, SHADER_TYPE shader_type) -> uint_fast32_t - см. выше     
* delete_shader(uint_fast32_t shader_id, SHADER_TYPE shader_type) - удаляет шейдер и высвобождает память     
* add_shaders_program(std::map<SHADER_TYPE, uint_fast32_t> shaders_id_map) -> uint_fast32_t линкует шейдеры в программ и возвращает id шейдерной программы     
* delete_shaders_program(uint_fast32_t shader_program_id) - удаляет шейдерную программу и очищает память     
* initialize_render_context(SDL_Window &window) - инициализирует контекст рендера (сокрее всего удалю, издержки проектирования и разбирания на ходу)     
* select_render_context() - делает текущий контекст активным настраивая все необходимое для рендера в текущий объект контекста (для многооконной системы)     
* prepare_new_frame(at::type::color::RGBA_at<uint8_t> color) - подготовка нового кадра (очистка буферов + получение размера области отрисовки)     

:black_square_button: Реализовать рендер для opengl    
* :black_square_button: draw_rectangle()     
* :black_square_button: draw_triangle()       
* :black_square_button: draw_circle()      
* :black_square_button: draw_text()       
* :black_square_button: draw_line()        
* :black_square_button: draw_frame()      
* :white_check_mark: draw_image(std::shared_ptr<type::image::Image> image, uint_fast32_t shader_program_id, Rect<int_fast32_t> rect)      
* :white_check_mark: add_shader(std::ifstream& shader_stream, SHADER_TYPE shader_type) -> uint_fast32_t          
* :white_check_mark: add_shader(u8string_at shader_file_name, SHADER_TYPE shader_type) -> uint_fast32_t        
* :white_check_mark: add_shader(std::stringstream& shader_stream, SHADER_TYPE shader_type) -> uint_fast32_t          
* delete_shader(uint_fast32_t shader_id, SHADER_TYPE shader_type) +           
* :white_check_mark: add_shaders_program(std::map<SHADER_TYPE, uint_fast32_t> shaders_id_map) -> uint_fast32_t      
* :white_check_mark: delete_shaders_program(uint_fast32_t shader_program_id)
* :white_check_mark: initialize_render_context(SDL_Window &window)    
* :white_check_mark: select_render_context()         
* :white_check_mark: prepare_new_frame(at::type::color::RGBA_at<uint8_t> color)      

:black_square_button: Реализовать рендер для vulkan (не начато)    

:white_check_mark: Реализовать статический метод возвращающий правильный рендер по RENDER_PROVIDER_TYPE (параметр конфигурации окна)     

---

- ### Gui types 

:white_check_mark: Класс для загрузки изображения при помощи stb. Конструктор скрыт, есть статический метод конструирующий shared_ptr     
Это дает возможность кидать указатель на изображение по программе не волнуясь что ее удалят перед рендером      
:white_check_mark: Добавить шаблонный Rect тип с x,y,width,height    
:white_check_mark: Добавить шаблонный Vector для 2D и 3D    

---

- ### Gui system

:white_check_mark: Понять как ImGui реализует отрисовку независимую от оконных систем    
|Как я понял есть буфер команд отрисовки который обрабатывается отдельной реализацией рендера    
По сути дерево виджетов реализует то же самое, но в виде дерева а не очереди команд. В конечном итоге разница только в реализации хранения|    

:black_square_button: Реализовать систему отрисовки виджетов    
Скорее всего будет в виде класса которому передается IRenderProvider и он отрисовывает по нему объекты

Реализовать систему виджетов позиционирования:     
  :black_square_button: "SingleFrame" - область в которую помещается 1 виджет (необходим как стартовый и для тестов)

Реализовать систему виджетов:    
  :black_square_button: Изображение - самоый простой виджет (функционал готов, надо объединить и виджет)


<details>
  <summary>Откуда ноги растут</summary>

Оставляю это для понимания откуда автор вдохновлялся (тырил) идеи

Частично копипастить систему ImGui с правками для реализации системы виджетов     
Как сделствие реализовать свои способы позиционирования элементов имплементированные в отдельные классы виджетов  

</details>  

:black_square_button: Добавить вывод текста через sdl2 ttf lib     
:black_square_button: Сделать парсер xml дерева для загрузки разметки изображения из xml файла     
Необходимо для загрузки макета из динамических библиотек редакторов    

:black_square_button: Добавить поддержку отрисовки на нескольких окнах     
Пока не уверен что возможно пудет с планируемой логикой, но в процессе увидем

---

- ### Project open/create

:black_square_button: Добавить стартовое окно открытия или создания проекта. Предпологаемый тип файла проекта .atproj    

---

- ### Core + core provider
:black_square_button: Реализовать общий класс объединяющий все вместе    
:black_square_button: Спроектировать класс - обертку для удобного использования из редактора бункционала движка    
Пока хз как правильно сделать, нодо думать

---

- ### Editor loader

:black_square_button: Добавить систему которая загружает dll в рантайме, получает из нее строку с разметкой редактора    
Привязка на стобытия виджетов будет реализована через имена функций из разметки. Из dll достаются функции по названию из разметки и кстанавливаются как коллбек для виджета

---

Пояснение идеи с редакторами: вся логика по сути крутится на объектах. Все на карте можно описать как объект + логика + система которая все связывает    
Каждый проект имеет отдельную базу sqlite. В базе есть таблица объектов (название + id)    
Отдельные редакторы добавляют свойства объекта. К примеру редактор 3d модели может добавить в базу 3D модель в отдельную таблицу и в последствии установить в таблице-соединители связь объекта и 3D мождели через fk на объект и на модель
Помимо редакторов в базе будет таблица с конфигурацией объекта, по которой при создании скрипта для объекта будет сгенерирован файл с dto, заполненный данными. Таким образом можно будет для отного объекта установить отдельные настройки.
Особняком стоит редактор карты, который будет сохранять в базе отдельные чанки + привязанные к ним объекты с отдельными конфигами и настройками размещения и масштабирования    
Разделения на уровни не будет, все будет сделано в рамках чанков. Чанк подгружает те чанки, которые указаны в конфиге чанка    
Таким образом если необходимо выгрузить текущую локацию и загрузить другую, то устанавливаем первому чанку в настройках подгружать нужный чанк, а в новом ставим не подргужать прошлые. Таким образом можно реализовать бесшовную подгрузку локаций    
Отдельные детали реализации будут описаны в процессе    

---

- ### Editor switcher

:black_square_button: Реализовать систему для смены реадкторов    
:black_square_button: Добавить по нажатию на таб окно блюра + колесо с выбором редактора    

---

- ### Db manager

:black_square_button: Реализовать менелжер базы для удобной работы из редакторов (тут отсылка к core provider)     

---
- ### Zip undixing utils

:black_square_button: Добавить утилиту в core provider для работы с архивами (мб замутить свой тип архива? Подумаем ...)    

---

- ### File manager

:black_square_button: Возможно добавить утилиту для более удобной работы с файлами из редакторов     
Будет видно по факту на сколько оно надо. Мб объединится с логикой Zip фрхивов     

---

- ### Resource manager

:black_square_button: Это что-то около работы с файловым менеджером     
Скорее всего будет отдельная абстракция для работы с разными предустановленными типами ресурсов по типу картинок. Сохранение в базу + взаимодействие с ними из скриптов. Возможно будет модульная система которая грузит файлы + сохраняет их тип и метданные для работы, реазируется как runtime dll load + паттерн стратеги  

---

- ### Render system

:black_square_button: Надо к гуи системе дореализовать рендер 3D объектов с блэкджеком и заданием шейдеров 

---

- ### Object view editor

Все было указано +- в поряде реализации, но это надо сделать как только будет достаточно утилит для реализации     
По сути когда реализую систему редакторов, надо будет первым делом реализовать этот редактор и на нем смотреть чего нехватает    

:black_square_button: Реализовать редактор 3D объектов    
:black_square_button: Один из пунктов это просмотр объекта с установленными шейдерами
Возможно будет редактор шейдеров, но это прям далекое будещее, пока скорее текстовый редактор))) 

---

- ### Map editor

:black_square_button: Реализовать систему рендера размещенных объектов на карте
:black_square_button: Реализовать по нажатию на прпавую кнопку меню с выбором объектов или редактированием выбранного объекта на карте    
Редактирование сводится к манипуляции с конфигом для задания отдельных свойств объекта    

:black_square_button: Добавить добавление чанков на карту и запретитьдобавление объектов вне чанков    
:black_square_button: Реализовать логику связей прогрузки чанков. Будет односторонняя связь между текущим чанком и какие подгружать находясь в нем    

:black_square_button: Добавить в меню правой кнопки раздел с включением определенной логики для объектов    
Т.е. можно будет включить обработку рендера для отдельных источников света и объектов со всеми шейдерами, при этом не обрабатывая лишние объекты. Или включить просчет физики для тестов азаимодействия объектов

---

- ### Physic edicor

:black_square_button: Взять готовый физический движок и вприсать его в рамки редактора\
:black_square_button: Добавить моделирование физики в редакторе карты

---

- ### Script system

:black_square_button: Реализовать редактор скриптов    
Генерится файл с DTO на основе конфига в базе для текущего объекта + .hpp и .cpp файл логики в которых можно писать скрипт    
В скрипт будет передаваться объект core provider для использования различных утилит + объект представляющий данный объект в коллекции объектов    
Из скриптов через core provider можно будет получить объекты из коллекции и редактировать их свойства/конфиги    
Не совсем удобно будет если конфиги будут храниться как void* , тогда прийдется их кастить к (заранее известном) типу конфига объекта         
Это так же влечет за собой необходимость при написании скрипта иметь хедер на DTO конфига редактируемого объекта   
Альтернативный вариант сделать секционные конфиги с полями union, но тогда прийдется смириться с оверхедом памяти при хранении мелких значений. Но это выгляит куда лучше
Возможно можно в union хранить ссылки на кучу с объектами конфига, тогда оверхеда в union не будет, но не уверен что так выйдет, хотя конкретных проблем пока не вижу    

---

- ### Make build system

:black_square_button: Сделать систему сборки артефактов, возможно интегрировать с редактором карт для запуска логики отдельных объектов    

---

- ### Tests

Эта штука как постоянная задача с пополняющимися пунктами

<details>
  <summary>Config manager</summary>

Менеджер конфигов удалил, чуть позже удалю тесты

:white_check_mark: Тест мнеджера конфигов с 1 секцией и 1 элементов в ней [.toml]     
:white_check_mark: Тест мнеджера конфигов с 2 секциями по 1 элементу в каждой [.toml]     
:white_check_mark: Тест мнеджера конфигов с 2 секциями в второй секции вложенная секция с 1 элементом [.toml]   

</details>

:white_check_mark: Тест создания лога и уничтожение до уничтожения менеджера логов     
:white_check_mark: Тест создания лога и уничтожение после уничтожения менеджера логов     
:white_check_mark: Тест лога info     
:white_check_mark: Тест лога debug     
:white_check_mark: Тест лога error     
:white_check_mark: Тест лога warning     
:white_check_mark: Тест лога fatal     
:black_square_button: Тестить все что есть     

---

- ### Some other trash :)

:black_square_button: Еще много надо сделать помимо описаного, но все описывать будет слишком долго, добавлю в процессе    

---



- Если что-то из этого окажется полезным, то просьба сообщить мне об этом для роста моего чсв) 

- Если есть какие-то идеи всегда приветствую - Evgenuy1605@yandex.ru


---

- ### Зависимости:

* [boost_1.75.0](https://www.boost.org/) - third_party_libs/boost_1_75_0 (вырезан функционал для тестов, но есть ненужные файлы т.к. было слишком долго чистить, да и не надо зная что скорее всего что-то еще добавится от-туда)
* [SDL2-2.0.14](https://www.libsdl.org/) - third_party_libs/SDL2-2.0.14 (все работа с окнами на нем)
* [nlohmann/json](https://github.com/nlohmann/json) - third_party_libs/json (юзаем конфиги в json)
* [ToruNiina/toml11](https://github.com/ToruNiina/toml11) - third_party_libs/toml11 [*Пока нет, но скоро добавится*]
* [STB](https://github.com/nothings/stb) - third_party_libs/stb (для загрузки изображений)